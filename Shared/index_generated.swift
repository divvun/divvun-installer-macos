// automatically generated by the FlatBuffers compiler, do not modify

import FlatBuffers

public enum pahkat {

public enum WindowsExecutableFlag: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case targetsystem = 0
	case targetuser = 1
	case requiresrebootonupdate = 32
	case requiresrebootonuninstall = 64
	case requiresrebootoninstall = 128


	public static var max: WindowsExecutableFlag { return .requiresrebootoninstall }
	public static var min: WindowsExecutableFlag { return .targetsystem }
}

public enum WindowsExecutableKind: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case msi = 1
	case inno = 2
	case nsis = 3


	public static var max: WindowsExecutableKind { return .nsis }
	public static var min: WindowsExecutableKind { return .none }
}

public enum MacOSPackageFlag: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case targetsystem = 0
	case targetuser = 1
	case requiresrebootonupdate = 32
	case requiresrebootonuninstall = 64
	case requiresrebootoninstall = 128


	public static var max: MacOSPackageFlag { return .requiresrebootoninstall }
	public static var min: MacOSPackageFlag { return .targetsystem }
}

public enum Payload: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case windowsexecutable = 1
	case macospackage = 2
	case tarballpackage = 3


	public static var max: Payload { return .tarballpackage }
	public static var min: Payload { return .none }
}

public enum Package: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case descriptor = 1
	case synthetic = 2
	case redirect = 3


	public static var max: Package { return .redirect }
	public static var min: Package { return .none }
}

public struct WindowsExecutable: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsWindowsExecutable(bb: ByteBuffer) -> WindowsExecutable { return WindowsExecutable(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var url: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var productCode: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var productCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var size: UInt64 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public var installedSize: UInt64 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public var flags: UInt8 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
	public var kind: pahkat.WindowsExecutableKind { let o = _accessor.offset(14); return o == 0 ? .none : pahkat.WindowsExecutableKind(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public var args: String? { let o = _accessor.offset(16); return o == 0 ? nil : _accessor.string(at: o) }
	public var argsSegmentArray: [UInt8]? { return _accessor.getVector(at: 16) }
	public var uninstallArgs: String? { let o = _accessor.offset(18); return o == 0 ? nil : _accessor.string(at: o) }
	public var uninstallArgsSegmentArray: [UInt8]? { return _accessor.getVector(at: 18) }
	public static func startWindowsExecutable(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
	public static func add(url: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: url, at: 0)  }
	public static func add(productCode: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: productCode, at: 1)  }
	public static func add(size: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: size, def: 0, at: 2) }
	public static func add(installedSize: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: installedSize, def: 0, at: 3) }
	public static func add(flags: UInt8, _ fbb: FlatBufferBuilder) { fbb.add(element: flags, def: 0, at: 4) }
	public static func add(kind: pahkat.WindowsExecutableKind, _ fbb: FlatBufferBuilder) { fbb.add(element: kind.rawValue, def: 0, at: 5) }
	public static func add(args: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: args, at: 6)  }
	public static func add(uninstallArgs: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: uninstallArgs, at: 7)  }
	public static func endWindowsExecutable(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
	public static func createWindowsExecutable(_ fbb: FlatBufferBuilder,
		offsetOfUrl url: Offset<String> = Offset(),
		offsetOfProductCode productCode: Offset<String> = Offset(),
		size: UInt64 = 0,
		installedSize: UInt64 = 0,
		flags: UInt8 = 0,
		kind: pahkat.WindowsExecutableKind = .none,
		offsetOfArgs args: Offset<String> = Offset(),
		offsetOfUninstallArgs uninstallArgs: Offset<String> = Offset()) -> Offset<UOffset> {
		let __start = WindowsExecutable.startWindowsExecutable(fbb)
		WindowsExecutable.add(url: url, fbb)
		WindowsExecutable.add(productCode: productCode, fbb)
		WindowsExecutable.add(size: size, fbb)
		WindowsExecutable.add(installedSize: installedSize, fbb)
		WindowsExecutable.add(flags: flags, fbb)
		WindowsExecutable.add(kind: kind, fbb)
		WindowsExecutable.add(args: args, fbb)
		WindowsExecutable.add(uninstallArgs: uninstallArgs, fbb)
		return WindowsExecutable.endWindowsExecutable(fbb, start: __start)
	}
}

public struct MacOSPackage: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsMacOSPackage(bb: ByteBuffer) -> MacOSPackage { return MacOSPackage(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var url: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var pkgId: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var pkgIdSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var size: UInt64 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public var installedSize: UInt64 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public var flags: UInt8 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
	public static func startMacOSPackage(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
	public static func add(url: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: url, at: 0)  }
	public static func add(pkgId: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: pkgId, at: 1)  }
	public static func add(size: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: size, def: 0, at: 2) }
	public static func add(installedSize: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: installedSize, def: 0, at: 3) }
	public static func add(flags: UInt8, _ fbb: FlatBufferBuilder) { fbb.add(element: flags, def: 0, at: 4) }
	public static func endMacOSPackage(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
	public static func createMacOSPackage(_ fbb: FlatBufferBuilder,
		offsetOfUrl url: Offset<String> = Offset(),
		offsetOfPkgId pkgId: Offset<String> = Offset(),
		size: UInt64 = 0,
		installedSize: UInt64 = 0,
		flags: UInt8 = 0) -> Offset<UOffset> {
		let __start = MacOSPackage.startMacOSPackage(fbb)
		MacOSPackage.add(url: url, fbb)
		MacOSPackage.add(pkgId: pkgId, fbb)
		MacOSPackage.add(size: size, fbb)
		MacOSPackage.add(installedSize: installedSize, fbb)
		MacOSPackage.add(flags: flags, fbb)
		return MacOSPackage.endMacOSPackage(fbb, start: __start)
	}
}

public struct TarballPackage: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsTarballPackage(bb: ByteBuffer) -> TarballPackage { return TarballPackage(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var url: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var size: UInt64 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public var installedSize: UInt64 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public static func startTarballPackage(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(url: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: url, at: 0)  }
	public static func add(size: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: size, def: 0, at: 1) }
	public static func add(installedSize: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: installedSize, def: 0, at: 2) }
	public static func endTarballPackage(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
	public static func createTarballPackage(_ fbb: FlatBufferBuilder,
		offsetOfUrl url: Offset<String> = Offset(),
		size: UInt64 = 0,
		installedSize: UInt64 = 0) -> Offset<UOffset> {
		let __start = TarballPackage.startTarballPackage(fbb)
		TarballPackage.add(url: url, fbb)
		TarballPackage.add(size: size, fbb)
		TarballPackage.add(installedSize: installedSize, fbb)
		return TarballPackage.endTarballPackage(fbb, start: __start)
	}
}

public struct Target: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsTarget(bb: ByteBuffer) -> Target { return Target(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var platform: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var platformSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var payloadType: pahkat.Payload { let o = _accessor.offset(6); return o == 0 ? .none : pahkat.Payload(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public func payload<T: FlatBufferObject>(type: T.Type) -> T? { let o = _accessor.offset(8); return o == 0 ? nil : _accessor.union(o) }
	public var dependenciesKeysCount: Int32 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func dependenciesKeys(at index: Int32) -> String? { let o = _accessor.offset(10); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var dependenciesValuesCount: Int32 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func dependenciesValues(at index: Int32) -> String? { let o = _accessor.offset(12); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var arch: String? { let o = _accessor.offset(14); return o == 0 ? nil : _accessor.string(at: o) }
	public var archSegmentArray: [UInt8]? { return _accessor.getVector(at: 14) }
	public static func startTarget(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
	public static func add(platform: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: platform, at: 0)  }
	public static func add(payloadType: pahkat.Payload, _ fbb: FlatBufferBuilder) { fbb.add(element: payloadType.rawValue, def: 0, at: 1) }
	public static func add(payload: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: payload, at: 2)  }
	public static func addVectorOf(dependenciesKeys: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: dependenciesKeys, at: 3)  }
	public static func addVectorOf(dependenciesValues: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: dependenciesValues, at: 4)  }
	public static func add(arch: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: arch, at: 5)  }
	public static func endTarget(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 8]); return end }
	public static func createTarget(_ fbb: FlatBufferBuilder,
		offsetOfPlatform platform: Offset<String> = Offset(),
		payloadType: pahkat.Payload = .none,
		offsetOfPayload payload: Offset<UOffset> = Offset(),
		vectorOfDependenciesKeys dependenciesKeys: Offset<UOffset> = Offset(),
		vectorOfDependenciesValues dependenciesValues: Offset<UOffset> = Offset(),
		offsetOfArch arch: Offset<String> = Offset()) -> Offset<UOffset> {
		let __start = Target.startTarget(fbb)
		Target.add(platform: platform, fbb)
		Target.add(payloadType: payloadType, fbb)
		Target.add(payload: payload, fbb)
		Target.addVectorOf(dependenciesKeys: dependenciesKeys, fbb)
		Target.addVectorOf(dependenciesValues: dependenciesValues, fbb)
		Target.add(arch: arch, fbb)
		return Target.endTarget(fbb, start: __start)
	}
}

public struct Release: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsRelease(bb: ByteBuffer) -> Release { return Release(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var versionType: UInt8 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
	public var version: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var versionSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var targetCount: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func target(at index: Int32) -> pahkat.Target? { let o = _accessor.offset(8); return o == 0 ? nil : pahkat.Target(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var channel: String? { let o = _accessor.offset(10); return o == 0 ? nil : _accessor.string(at: o) }
	public var channelSegmentArray: [UInt8]? { return _accessor.getVector(at: 10) }
	public var authorsCount: Int32 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func authors(at index: Int32) -> String? { let o = _accessor.offset(12); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var license: String? { let o = _accessor.offset(14); return o == 0 ? nil : _accessor.string(at: o) }
	public var licenseSegmentArray: [UInt8]? { return _accessor.getVector(at: 14) }
	public var licenseUrl: String? { let o = _accessor.offset(16); return o == 0 ? nil : _accessor.string(at: o) }
	public var licenseUrlSegmentArray: [UInt8]? { return _accessor.getVector(at: 16) }
	public static func startRelease(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
	public static func add(versionType: UInt8, _ fbb: FlatBufferBuilder) { fbb.add(element: versionType, def: 0, at: 0) }
	public static func add(version: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: version, at: 1)  }
	public static func addVectorOf(target: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: target, at: 2)  }
	public static func add(channel: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: channel, at: 3)  }
	public static func addVectorOf(authors: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: authors, at: 4)  }
	public static func add(license: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: license, at: 5)  }
	public static func add(licenseUrl: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: licenseUrl, at: 6)  }
	public static func endRelease(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6]); return end }
	public static func createRelease(_ fbb: FlatBufferBuilder,
		versionType: UInt8 = 0,
		offsetOfVersion version: Offset<String> = Offset(),
		vectorOfTarget target: Offset<UOffset> = Offset(),
		offsetOfChannel channel: Offset<String> = Offset(),
		vectorOfAuthors authors: Offset<UOffset> = Offset(),
		offsetOfLicense license: Offset<String> = Offset(),
		offsetOfLicenseUrl licenseUrl: Offset<String> = Offset()) -> Offset<UOffset> {
		let __start = Release.startRelease(fbb)
		Release.add(versionType: versionType, fbb)
		Release.add(version: version, fbb)
		Release.addVectorOf(target: target, fbb)
		Release.add(channel: channel, fbb)
		Release.addVectorOf(authors: authors, fbb)
		Release.add(license: license, fbb)
		Release.add(licenseUrl: licenseUrl, fbb)
		return Release.endRelease(fbb, start: __start)
	}
}

public struct Descriptor: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsDescriptor(bb: ByteBuffer) -> Descriptor { return Descriptor(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var releaseCount: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func release(at index: Int32) -> pahkat.Release? { let o = _accessor.offset(6); return o == 0 ? nil : pahkat.Release(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public var nameKeysCount: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func nameKeys(at index: Int32) -> String? { let o = _accessor.offset(8); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var nameValuesCount: Int32 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func nameValues(at index: Int32) -> String? { let o = _accessor.offset(10); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var descriptionKeysCount: Int32 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func descriptionKeys(at index: Int32) -> String? { let o = _accessor.offset(12); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var descriptionValuesCount: Int32 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func descriptionValues(at index: Int32) -> String? { let o = _accessor.offset(14); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var tagsCount: Int32 { let o = _accessor.offset(16); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func tags(at index: Int32) -> String? { let o = _accessor.offset(16); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public static func startDescriptor(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func addVectorOf(release: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: release, at: 1)  }
	public static func addVectorOf(nameKeys: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: nameKeys, at: 2)  }
	public static func addVectorOf(nameValues: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: nameValues, at: 3)  }
	public static func addVectorOf(descriptionKeys: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: descriptionKeys, at: 4)  }
	public static func addVectorOf(descriptionValues: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: descriptionValues, at: 5)  }
	public static func addVectorOf(tags: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: tags, at: 6)  }
	public static func endDescriptor(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
	public static func createDescriptor(_ fbb: FlatBufferBuilder,
		offsetOfId id: Offset<String> = Offset(),
		vectorOfRelease release: Offset<UOffset> = Offset(),
		vectorOfNameKeys nameKeys: Offset<UOffset> = Offset(),
		vectorOfNameValues nameValues: Offset<UOffset> = Offset(),
		vectorOfDescriptionKeys descriptionKeys: Offset<UOffset> = Offset(),
		vectorOfDescriptionValues descriptionValues: Offset<UOffset> = Offset(),
		vectorOfTags tags: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Descriptor.startDescriptor(fbb)
		Descriptor.add(id: id, fbb)
		Descriptor.addVectorOf(release: release, fbb)
		Descriptor.addVectorOf(nameKeys: nameKeys, fbb)
		Descriptor.addVectorOf(nameValues: nameValues, fbb)
		Descriptor.addVectorOf(descriptionKeys: descriptionKeys, fbb)
		Descriptor.addVectorOf(descriptionValues: descriptionValues, fbb)
		Descriptor.addVectorOf(tags: tags, fbb)
		return Descriptor.endDescriptor(fbb, start: __start)
	}
}

public struct Synthetic: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsSynthetic(bb: ByteBuffer) -> Synthetic { return Synthetic(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var todo: UInt8 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
	public static func startSynthetic(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(todo: UInt8, _ fbb: FlatBufferBuilder) { fbb.add(element: todo, def: 0, at: 0) }
	public static func endSynthetic(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createSynthetic(_ fbb: FlatBufferBuilder,
		todo: UInt8 = 0) -> Offset<UOffset> {
		let __start = Synthetic.startSynthetic(fbb)
		Synthetic.add(todo: todo, fbb)
		return Synthetic.endSynthetic(fbb, start: __start)
	}
}

public struct Redirect: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsRedirect(bb: ByteBuffer) -> Redirect { return Redirect(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var url: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public static func startRedirect(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(url: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: url, at: 0)  }
	public static func endRedirect(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
	public static func createRedirect(_ fbb: FlatBufferBuilder,
		offsetOfUrl url: Offset<String> = Offset()) -> Offset<UOffset> {
		let __start = Redirect.startRedirect(fbb)
		Redirect.add(url: url, fbb)
		return Redirect.endRedirect(fbb, start: __start)
	}
}

public struct Packages: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsPackages(bb: ByteBuffer) -> Packages { return Packages(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var packagesKeysCount: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func packagesKeys(at index: Int32) -> String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var packagesValuesTypesCount: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func packagesValuesTypes(at index: Int32) -> UInt8 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
	public var packagesValuesTypes: [UInt8] { return _accessor.getVector(at: 6) ?? [] }
	public var packagesValuesCount: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func packagesValues(at index: Int32) -> pahkat.Descriptor? { let o = _accessor.offset(8); return o == 0 ? nil : pahkat.Descriptor(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startPackages(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func addVectorOf(packagesKeys: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: packagesKeys, at: 0)  }
	public static func addVectorOf(packagesValuesTypes: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: packagesValuesTypes, at: 1)  }
	public static func addVectorOf(packagesValues: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: packagesValues, at: 2)  }
	public static func endPackages(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createPackages(_ fbb: FlatBufferBuilder,
		vectorOfPackagesKeys packagesKeys: Offset<UOffset> = Offset(),
		vectorOfPackagesValuesTypes packagesValuesTypes: Offset<UOffset> = Offset(),
		vectorOfPackagesValues packagesValues: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Packages.startPackages(fbb)
		Packages.addVectorOf(packagesKeys: packagesKeys, fbb)
		Packages.addVectorOf(packagesValuesTypes: packagesValuesTypes, fbb)
		Packages.addVectorOf(packagesValues: packagesValues, fbb)
		return Packages.endPackages(fbb, start: __start)
	}
}

}

// MARK: - pahkat


